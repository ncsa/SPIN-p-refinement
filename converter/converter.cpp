#include "converter.h"

// Program to convert from .msh to .vtk files

void Converter::convert( string msh_file )
{
	ifstream se;
	se.open( msh_file, fstream::in );

	if( !se.is_open() ){
		cout << "Failed to open " << msh_file << endl;
		exit(1);
	}

	ofstream output;
	string output_file = msh_file.substr(0, msh_file.length() - 3);
	output_file += "vtk";
	output.open( output_file );

	if( !output.is_open() )
	{
		cout << "Failed to open " << output_file << endl;
		exit(1);
	}

	output << "# vtk DataFile Version 3.0" << "\n";
	// Should version not always be 3.0?
	output << "Autogenerated vtk file from " << msh_file << " by Dan Gross\n";
	output << "ASCII\n\n";
	output << "DATASET UNSTRUCTURED_GRID" << "\n";

	string line;
	int num_nodes = 0;
	int num_elems = 0;

	while( getline( se, line ))
	{
		// $Nodes
		if( line.compare("$Nodes") == 0 )
		{
			// First line is the number of nodes
			getline( se, line );
			num_nodes = stoi(line);
			output << "POINTS       " << num_nodes << " float\n";
			getline( se, line );
			string line_sub = "";

			// Loop through all 'node' lines
			while( line.compare("$EndNodes") != 0 )
			{
				for(int i = 0; i < line.length(); i++)
				{
					// Get rid of the node id (not included in vtk files)
					if( line.at(i) == ' ' )
					{
						line_sub = line.substr(i + 1, line.length() - (i + 1));
						break;
					}
				}
				// Print node coords to output file
				output << line_sub << endl;
				getline( se, line );
			}
		}

		// $Elements
		if( line.compare("$Elements") == 0 )
		{
			// First line is number of elements
			getline( se, line );
			int total_elem = stoi(line);
			getline( se, line );
			// Save position of first element
			int stream_pos = se.tellg();
			// Iterate through elements to get total size and number of relevant elements
			pair<int, int> elem_info = Converter::getSize( se, line );
			int num_elems = elem_info.second;
			int size = elem_info.first;
			output << "\nCELLS         " << num_elems << "          " << size << "\n";
			// Return to first element
			se.seekg( stream_pos );

			// Skip the non-important elements (nodes, lines)
			for(int i = 0; i < (total_elem - num_elems); i++){
				getline( se, line );
			}

			vector<char> cell_types;

			// Reiterate elements and push to output
			while( line.compare("$EndElements") != 0 )
			{
				pair<int, string> node_info = Converter::getNodes( line );
				output << node_info.second << "\n";
				cell_types.push_back( node_info.first );
				getline( se, line );
			}

			output << "\nCELL_TYPES         " << num_elems << "\n";
			for(int i = 0; i < cell_types.size(); i++)
			{
				int cell_type = cell_types.at(i);

				switch(cell_type){
					case 2:	output << "5\n";	// 3-node triangle
							break;
					case 3: output << "9\n";	// 4-node quadrangle
							break;
					case 4: output << "10\n";	// 4-node tetrahedron
							break;
					case 5: output << "12\n";	// 8-node hexahedron
							break;
					case 7: output << "14\n";	// 5-node pyramid
							break;
					case 8: output << "21\n";	// 3-node second order line
							break;
					case 9: output << "22\n";	// 6-node second order triangle
							break;
					case 11: output << "24\n";	// 10-node second order tetrahedron
							 break;
					default: break;
				}
			}
		}
	}
}

/*
*	Returns the important node information from an Element msh line
* 	returns: (element type, nodes)
*/

pair<int, string> Converter::getNodes( string line )
{
	pair<int, string> node_info;

	stringstream line_stream(line);
	string elm_var;
	string nodes = "";
	int num_elems = 0;

	line_stream >> elm_var;
	line_stream >> elm_var;

	int elem_type = stoi( elm_var );
	node_info.first = elem_type;

	// Parse line to the num_tags element
	for(int i = 0; i < 1; i++)
	{
		line_stream >> elm_var;
	}

	int num_tags = stoi(elm_var);
	// Parse through the total number of tags
	for(int i = 0; i < num_tags; i++)
	{
		line_stream >> elm_var;
	}

	while( line_stream >> elm_var )
	{
		int node_num = stoi(elm_var) - 1;
		nodes += "        " + to_string(node_num);
		num_elems++;
	}

	nodes = to_string(num_elems) + nodes;
	node_info.second = nodes;
	return node_info;

}

/*
*	Returns a pair<int, int> that holds (size, num_elems)
*/

pair<int, int> Converter::getSize( ifstream &se, string line )
{
	int size = 0;
	int num_elems = 0;
	pair<int, int> elem_info;
	while( line.compare("$EndElements") != 0 )
	{
		// Line format =: elm-num elm-type num-tags [tags] [nodes]
		int step = 0;
		string str_elm_type = "";

		for(int i = 0; i < line.length(); i++)
		{
			if( step == 1 ) // Collect elm-type string
			{
				if( line.at(i) ==  ' ' )
				{
					int elm_type = stoi(str_elm_type);

					switch( elm_type ) 
					{
						case 2: size += 4;
								num_elems++;
								break;
						case 3: size += 5;
								num_elems++;
								break;
						case 4: size += 5;
								num_elems++;
								break;
						case 5: size += 9;
								num_elems++;
								break;
						default: break;
					}

					step = 2;	
				}
				else
				{
					str_elm_type += line.at(i);
				}
			}

			if( line.at(i) == ' ' && step == 0 ) // First space
			{
				step = 1;
			}
		}

		getline( se, line );
	}

	elem_info.first = size;
	elem_info.second = num_elems;

	return elem_info;
}






